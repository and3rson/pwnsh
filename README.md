# pwnsh

Reverse shell over DNS для Windows (Pwn-Shell!)

Автор - Андрій "Андерсон" Дунай.

Ліцензія - [WTFPL](http://www.wtfpl.net/).

## Компоненти

- `client` - клієнтська аплікація на C++, будується за допомогою MinGW.

  Не залежить від `libstdc++` для покращення переносності і зменшення розміру бінарника (жодних векторів та new/delete - тільки stdlib, тільки олдскул!)

  Фінальний бінарник після `strip` займає <50 КБ.

  Збірка та запуск:

  ```sh
  $ cd client
  $ make
  $ # або:
  $ make DNS_SERVER=127.0.0.1 DNS_POLL_INTERVAL=1000
  $ ./pwnsh.exe
  ```

- `server` - імплементація контролера для клієнта. Написана на Go.

  Збірка та запуск:

  ```sh
  $ cd server
  $ go run . 0.0.0.0:53
  $ # для побудови бінарника:
  $ go build .
  ```

## Як це працює

Клієнт здійснює полінг DNS-сервера за допомогою TXT-запитів. Хост в запиті - це дані, які клієнт хоче передати серверу. Відповідь - це дані, які сервер хоче передати клієнту.

Якщо клієнт не має жодних даних для сервера, він надсилає пустий TXT-запит.

Якщо сервер не має команд для клієнта, які очікують виконання, то він надсилає пусту TXT-відповідь.

Всі дані кодуються в base64 з деякими модифікаціями (`_-` замість `+/`), щоб виглядати як валідні ідентифікатори і не дратувати фаєрволи.

Пусті запити містять лише крапку (`DnsQuery_A` автоматично дописує її в кінці хоста в кожному запиті).

## Речі, які можна легко вдосконалити

- Я звик писати коментарі і логи англійською мовою, тому в цьому коді буде суміш англійської та української мов.
- Дані не шифруються. Перед бойовим використанням варто було б використати принаймні якийсь симетричний алгоритм.
- Як і вказано в завданні, кожна команда запускається в окремій оболонці.
  Проте було б нескладно додати можливість використання оболонки в інтерактивному режмиі впродовж тривалішого часу - це б спростило навігацію по системі.
- Поточна імплементація сервера розрахована на єдиного активного клієнта. Можна додати можливість обирати, якому з клієнтів надсилати команду.
